### Mapeamento Requisitos-Código

Esta seção mapeia os requisitos do projeto (gerais e específicos do tema) para as seções correspondentes no código-fonte, demonstrando a aplicação prática dos conceitos estudados e o cumprimento dos objetivos.

| Requisito | Arquivo(s) Relevante(s) | Implementação e Justificativa |
| :--- | :--- | :--- |
| **1. Threads (Geral)** | `Server.cpp`, `client_cli.cpp`, `Logger.cpp` | **Servidor:** Adota o modelo "thread-por-cliente", onde a função `run_accept_loop()` instancia uma `std::thread` para cada nova conexão aceita. Isso permite o processamento simultâneo e isolado de múltiplos clientes. <br> **Cliente:** Utiliza duas threads para resolver o problema de I/O bloqueante: a thread principal para `std::getline` (entrada do usuário) e uma `receiver_thread` dedicada para `recv` (recebimento de dados da rede), garantindo a responsividade da interface. <br> **Logger:** Possui uma `consumer_thread_` interna, que processa a fila de logs em segundo plano. |
| **2. Exclusão Mútua (Geral)** | `Server.hpp`, `Server.cpp`, `Logger.cpp` | **Servidor:** Um `std::mutex` (`clients_mutex_`) protege todo o estado compartilhado (mapas de usuários, credenciais e acesso ao `users.txt`). O `std::lock_guard` é usado em todas as seções críticas para garantir a atomicidade das operações e prevenir *race conditions*. <br> **Logger:** Um mutex (`mtx_`) protege o acesso à fila de mensagens (`message_queue_`), garantindo que a adição de logs por múltiplas threads seja segura. |
| **3. Variáveis de Condição (Geral)** | `Logger.hpp`, `Logger.cpp` | A classe `Logger` utiliza uma `std::condition_variable` (`cv_`) para implementar o padrão Produtor-Consumidor de forma eficiente. A thread consumidora "dorme" com `cv_.wait()`, sendo acordada apenas quando há novas mensagens, o que evita o uso de *busy-waiting* (polling), economizando recursos do sistema. |
| **4. Monitores (Geral)** | `Logger.hpp`, `Logger.cpp` | A classe `Logger` é uma implementação prática do padrão **Monitor**. Ela encapsula o recurso compartilhado (a fila de logs) e todas as primitivas de sincronização (`mutex` e `condition_variable`) em um único objeto, oferecendo uma interface pública (`log()`) que é inerentemente thread-safe. |
| **5. Sockets (Geral)** | `Server.cpp`, `client_cli.cpp` | A API de Sockets Berkeley é a base da comunicação em rede. O servidor usa a sequência `socket()`, `bind()`, `listen()`, `accept()`, e o cliente usa `socket()` e `connect()`. Ambos utilizam `send()` e `read()`/`recv()` para a troca de dados. |
| **6. Gerenciamento de Recursos (Geral)**| `Server.cpp`, `Logger.cpp`| O princípio RAII é aplicado com `std::lock_guard`. Os destrutores (`~Server`, `~Logger`) garantem a liberação de recursos, como o fechamento do socket do servidor e do arquivo de log. A thread do logger é finalizada de forma segura com `join()`. |
| **7. Tratamento de Erros (Geral)** | `Server.cpp`, `client_cli.cpp`, `main.cpp` | Os valores de retorno de chamadas de sistema críticas (ex: `socket()`, `bind()`) são verificados. Erros são reportados no log do servidor ou no `stderr` do cliente, com encerramento do programa em casos irrecuperáveis. |
| **8. Logging Concorrente (Tema)** | `Logger.hpp`, `Logger.cpp`, `Server.cpp` | Foi implementado um sistema de logging concorrente do zero na classe `Logger`, em vez de usar `libtslog`, para demonstrar de forma mais aprofundada o domínio dos conceitos de mutex, variáveis de condição e do padrão Monitor, que são requisitos centrais do projeto. Os logs são salvos de forma segura em `chat_server.log`. |
| **9. Documentação (Geral)** | `DiagramaEtapa3.jpg` | Um diagrama de sequência foi criado para ilustrar o fluxo de comunicação entre múltiplos clientes e o servidor, incluindo a conexão, o broadcast de mensagens e a desconexão. |
| **10. Build (Geral)** | `Makefile` | Um `Makefile` automatiza a compilação do servidor (`chat_server`) e do cliente (`chat_client`), definindo as flags necessárias (`-std=c++17`, `-pthread`) e gerenciando as dependências dos arquivos. |
| **11. Uso de IA/LLMs (Geral)** | `RELATORIO.md` | O relatório de análise crítica foi desenvolvido em diálogo com um LLM para investigar e validar as decisões de design de concorrência, conforme detalhado no próprio documento. |
| **Broadcast de Mensagens (Tema)** | `Server.cpp` | A função `broadcast_message` é chamada quando uma mensagem pública é recebida. Ela itera sobre a lista de usuários autenticados e envia a mensagem para todos, exceto o remetente original. O acesso à lista é protegido por mutex. |
| **Autenticação e Registro (Opcional)** | `Server.cpp`, `client_cli.cpp`, `users.txt` | Um sistema de contas completo foi implementado. O servidor gerencia os comandos `AUTH` e `REGISTER`, validando credenciais e persistindo novos usuários no arquivo `users.txt`. Todo o processo é protegido por mutex para garantir a atomicidade das operações. |
| **Mensagens Privadas (Opcional)** | `Server.cpp` | A funcionalidade foi implementada com o comando `/priv <usuário> <mensagem>`. O servidor possui uma lógica (`handle_private_message`) para parsear o comando, encontrar o socket do destinatário no mapa `username_to_socket_` e enviar a mensagem diretamente, garantindo a privacidade. |